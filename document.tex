% arara: pdflatex
\documentclass{bioinfo}
\copyrightyear{2015}
\pubyear{2015}

\usepackage{hyperref}
\newcommand\fnurl[2]{%
  \href{#1}{#2}\footnote{\url{#1}}%
}

\usepackage{listings}
\usepackage[usenames,dvipsnames,svgnames,table,x11names]{xcolor}
\lstdefinelanguage{EcmaScript} {
    morekeywords={
        break,class,const,continue,delete,do,extends,get,set,while,export,for,in,function,
        if,else,import,in,instanceOf,label,let,new,of,return,switch,this,
        throw,try,catch,typeof,var,void,with,yield
    },
    sensitive=false,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
    morestring=[d]'
    morestring=[d]`
}

\lstset{
    basicstyle=\footnotesize\ttfamily,
    showstringspaces=false,
    keywordstyle=\ttfamily\bfseries\color{CadetBlue},
    identifierstyle=\ttfamily,
    stringstyle=\ttfamily\color{OliveGreen},
    commentstyle=\color{Gray},
    language=EcmaScript,
    xleftmargin=0.2cm,
    frame=tb,
    framesep=5pt,
    rulecolor=\color{LightGray}
}

\begin{document}

\title[short Title]{ES6 --- Modern Javascript}
\author[Smarschevski, Gloster]{Jan Smarschevski\,$^{1}$, Robin Gloster\,$^{2}$}
\address{$^{1}$jan.smarschevski@tum.de\\
$^{2}$robin.gloster@tum.de}

\maketitle

\begin{abstract}
ECMAScript 6 (ES6/ES2015) is the 6th release (June 2015) of a language specification standardized by
Ecma International with Javascript being the implementation of this standard. Currently many
features of ES6 are already supported by the newest versions of modern browsers like Chrome,
Firefox and Edge. The full compatability table can be found here https://kangax.github.io/compat-
table/es6/
There are many new features in ES6 and some of the more important ones will be presented in this
elaboration.

\section{Contact:} \href{name@bio.com}{name@bio.com}
\end{abstract}

\section{Variable Declarations --- Let \& Const}
\paragraph{ES5 scoping\textcolon}
Variable scoping in EcmaScript prior to version 6 is specified to use function scope.
Any variable declared with {\tt var} is accessible in the whole function including
code preceding the declaration statement. This mechanism is called {\em variable hoisting}.
If a variable is not declared, but gets defined a value the variable is automatically declared
on the outermost scope, in case of browsers on {\tt window}. This causes issues in code, due
to not being obvious in certain places.

Variables in loop definitions are ``leaked'' to the scope of the surrounding function; Code
with the intention to access or set a variable from an outer scope, having a variable of
the same name being declared later in its scope ({\em shadowing}) will not operate on the
outer variable as could be expected.

All problems mentioned are identified by all common linters (i.e. jslint, jshint, eslint)
or IDEs.


\paragraph{let \& const\textcolon}
The EcmaScript 6 standard introduces two new declaration keywords. {\tt let} declares
a variable {\tt const} a constant which are block scoped and neither can be redeclared in the
same scope. Declarations in loop/if-statement headers are scoped in the loop/if block.
Additionally to avoid unexpected behaviour, access to these variables prior
to a declaration in the same scope causes an error, called access in
the {\em Temporal Dead Zone}.

Declarations with {\tt const} do not affect inner mutability of the value; mutating, adding and
deleting properties is allowed. Mutation of the variable itself is forbidden i.e. re-assigning
or modifying a literal. Hence {\tt const} declarations without definition cause a syntax error.

In order to ensure babel checking the Temporal Dead Zone the optional rule
{\tt es6.spec.blockScoping} has to be enabled. This rule causes errors in Internet Explorer 9
due to it not supporting {\sl Strict Mode} breaking the implementation by mutating the live
{\tt arguments} variable. Hence this should only turned on in development and disabled in production
to ensure maximum browser compatibility.
The main developers have stated in
\fnurl{https://babeljs.slack.com/archives/development/p1442185357000044}{chat}, that this will
be fixed using static analysis in the upcoming Babel 6 release, originally slated for 28/09/2015.

\section{Functions}
\paragraph{Arrow Functions}
Arrow functions bring a new and clearer syntax for writing functions, although
they always are anonymous and therefore not a replacement for the function keyword.
In ES5: function (arguments) { expression }
In ES6: (arguments) => {expression}
This is very handy for example to reduce a short function to a single line expression.
These functions also introduce new functionality, namely lexical scoping.
In Javascript functions always create their own scope, but arrow functions
rather inherit their scope from the enclosing function.

\begin{lstlisting}
function countTables(waiter) {
    this.counter = 0;
    waiter.askSomeone(
        (response) => {
            this.counter = response + 1;
        }
    );
}
\end{lstlisting}

Without arrow functions the {\tt this} reference would be different in
{\tt countTables()} and {\tt askSomeone()} and therefore a
solution would be to use {\tt .bind(this)} on the inner function or store
{\tt this} in a variable:

\begin{lstlisting}
function countTables(waiter) {
    var self = this;
    this.counter = 0;
    waiter.askSomeone(
        (response) => {
            self.counter = response + 1;
        }
    );
}
\end{lstlisting}

This is pretty cumbersome and non-intuitive, which is why arrow functions
have been introduced to provide a clear solution for similar problems.

\paragraph{Default Parameters\textcolon}
ES6 allows function parameters to have a default value defined. This value gets used when
no parameter is passed to the function or the value of the parameter is {\tt undefined} as
this is per specification the value for not passing an argument.

\begin{lstlisting}
function fn(param = "default") {
    return param;
}

console.log(fn()); // === "default"
\end{lstlisting}

\paragraph{Rest Parameters\textcolon}
Introduced in the new standard is a new mechanism to collect a varying number of parameters.
In previous versions of the language this could be achieved by using the array-like
{\tt arguments} variable.

\begin{lstlisting}
function fn(a, b, ...rest) {
    return rest;
}

console.log(fn(1, 2, 3, 4, 5)); // === [3, 4, 5]
\end{lstlisting}

\paragraph{Spread Operator}
The triple-dot-operator used with rest parameters can also be used in function invocations
to apply an array of parameters to a function. This replaces the need to use {\tt Function.apply}
when not having to specify a scope.

\begin{lstlisting}
function fn(a, b, c) {
    return [a, b, c];
}

const params = [1, 2, 3];
console.log(fn(...params)); // === [1, 2, 3]
\end{lstlisting}

\section{for-of-loop}
In ES5 there is the for-in loop and the forEach loop.
The for-in loop loops over all properties of an object. Example:
\begin{lstlisting}
var food = [“banana”, “orange”, “apple”]
food.RandomProperty = “123”;
for (var x in food) { ... }
\end{lstlisting}
The goal is to loop over the food array, but with the for-of loop we would also loop over the property
“RandomProperty” and most likely get a unwanted result.
The forEach loop in this example would be:
\begin{lstlisting}
food.forEach(function (entry) { ... }
\end{lstlisting}
This loop actually loops over the array elements only, but there is a problem. You can’t return or
break out of the forEach loop. This is not very efficient as the array is always fully traversed.
Therefore the for-of loop was introducted as both loops (for-in and forEach) have their flaws.
Staying in the example:
\begin{lstlisting}
for (var x of food) { ...}
\end{lstlisting}

 would give the desired result, without any quirks. A very important note is
that the for-of loop only works for iterable objects like array, map or set (ES6 introduces the new
datastructres map and set).

\section{Destructuring}
The possibility to destructure arrays and objects has been made possible with
the ES6 standard.

\begin{lstlisting}
let [a, b] = [1, 2];
console.log(a, b); // => 1, 2
\end{lstlisting}

Missing values are set to {\tt undefined}; superflous are ignored; nested destructring
defaults and collecting rest values at the end are possible.
Practical appliances are returning multiple values or swapping variables
without the need for a temporary variable.

\begin{lstlisting}
let [a, b, c] = [1, 2];
console.log(a, b, c); // => 1, 2, undefined

let [d, e] = [1, 2, 3];
console.log(d, e); // => 1, 2

let [f, [g, [h]]] = [1, [2, [3]]];
console.log(f, g, h); // => 1, 2, 3

let [j, k, ...rest] = [1, 2, 3, 4, 5];
console.log(j, k, rest); // => 1, 2, [3, 4, 5]

let [l, m, n = 3] = [1, 2];
console.log(l, m, n); // => 1, 2, 3

let x = 1, y = 2;
[x, y] = [y, x];
console.log(x, y); // => 2, 1
\end{lstlisting}

Object destructuring
\begin{lstlisting}

\end{lstlisting}

\section{Class \& Subclassing}
Objects already exists in ES5, but the main problem is the non-intuitive and complex
way to write object-oriented programs. ES6 introduces syntactical sugar for objects
and prototypes. The main advantage is the clean and concise syntax for creating
objects and for dealing with inheritance. The syntax is well-known from other
object-oriented languages like Java or C++.

 Example for a class in ES6:
\begin{lstlisting}
class Circle {
//add static property (actually already an ES7 feature)
static circlesMade = 0;
// instance property
color = 'red';
constructor(radius) {
this.radius = radius;
Circle.circlesMade++;
}
//class method
static draw(circle, canvas) {
//Code for drawing on Canvas
}
//instance method
area() {
return Math.pow(this.radius, 2) * Math.PI;
}
//getter and setter
get radius() {
return this.radius;
}
set radius(radius) {
if (!Number.isInteger(radius))
throw new Error("Circle radius must be an integer.");
this._radius = radius;
};
}
}

//example for subclassing with the super keyword
class ScalableCircle extends Circle {
constructor(scalingFactor) {
super();
this.scalingFactor = scalingFactor;
}
get radius() {
return this.scalingFactor * super.radius;
}
set radius(radius) {
throw new Error("ScalableCircle radius is constant.");
}
}
\end{lstlisting}

5. Template Strings
Template Strings enhance the way for writing strings. The main feature is to manipulate the string by
directly embedding an expression into the string.
Example:
\begin{lstlisting}
var a = 3;
var b = 5;
var sum = `Your total is : ${a + b}`;
\end{lstlisting}
So the syntax are two backticks (!) and the dollar sign with the curly braces.
Inside the curly braces you can put any expression like inline math or a function call.
With Template Strings you can now also write multi line strings without any ``hacks'' like
concatenation or line break character. All characters like whitespace in a template string
are not ignored.

%\bibliographystyle{natbib}
%\bibliographystyle{achemnat}
%\bibliographystyle{plainnat}
%\bibliographystyle{abbrv}
%\bibliographystyle{bioinformatics}
%
%\bibliographystyle{plain}
%
%\bibliography{Document}

\begin{thebibliography}{}
\bibitem[Bofelli {\it et~al}., 2000]{Boffelli03} Bofelli,F., Name2, Name3 (2003) Article title, {\it Journal Name}, {\bf 199}, 133-154.

\bibitem[Bag {\it et~al}., 2001]{Bag01} Bag,M., Name2, Name3 (2001) Article title, {\it Journal Name}, {\bf 99}, 33-54.

% \bibitem[Yoo \textit{et~al}., 2003]{Yoo03}
% Yoo,M.S. \textit{et~al}. (2003) Oxidative stress regulated genes
in nigral dopaminergic neurnol cell: correlation with the known
pathology in Parkinson's disease. \textit{Brain Res. Mol. Brain
Res.}, \textbf{110}(Suppl. 1), 76--84.

\bibitem[Lehmann, 1986]{Leh86}
Lehmann,E.L. (1986) Chapter title. \textit{Book Title}. Vol.~1, 2nd edn. Springer-Verlag, New York.

\bibitem[Crenshaw and Jones, 2003]{Cre03}
Crenshaw, B.,III, and Jones, W.B.,Jr (2003) The future of clinical
cancer management: one tumor, one chip. \textit{Bioinformatics},
doi:10.1093/bioinformatics/btn000.

\bibitem[Auhtor \textit{et~al}. (2000)]{Aut00}
Auhtor,A.B. \textit{et~al}. (2000) Chapter title. In Smith, A.C.
(ed.), \textit{Book Title}, 2nd edn. Publisher, Location, Vol. 1, pp.
???--???.

\bibitem[Bardet, 1920]{Bar20}
Bardet, G. (1920) Sur un syndrome d'obesite infantile avec
polydactylie et retinite pigmentaire (contribution a l'etude des
formes cliniques de l'obesite hypophysaire). PhD Thesis, name of
institution, Paris, France.

\end{thebibliography}
\end{document}
